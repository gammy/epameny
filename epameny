#!/usr/bin/env bash
# epameny: A ridiculous ANSI menu.
# By gammy, anno 2025. To reach me, try https://github.com/gammy
#
# This definitely will NOT work on all setups: up/down keycodes are precarious
# at best & printing won't work properly if entries can't fit in the terminal.
#
# Only use this for lazy hacks; dialog (1) is a far more sane choice.
#
# Copyright (C) 2025 Kristian Gunstone
# Use of this source code is governed by the Simplified BSD License:
# https://opensource.org/license/bsd-2-clause

VERSION='0.9.3'

show_usage() {
    local self=$(basename "$0")
    cat <<EOF
$self v$VERSION: A ridiculous ANSI menu

Usage:
  $self <title> <default item index> <item label> <item value> [...]

The interactive menu is printed to standard error, and the selection
is printed to standard output in the form '<item index> <item value>'
where the former is, like the default item index, a 0-indexed integer
counting from the first item supplied, and the latter is the
corresponding item's value, with no additional quoting or escaping.
A negative default index can be used to select items in reverse order.

Keys:
  ISO up / down or 'l' / 'j' moves the selection up / down
  RETURN / ENTER confirms the item selection and exits
  'q' exits immediately (as does choosing a '::quit::'-value)

Exit states:
  On immediate exit     : Exit code 2, prints nothing to stdout
  On interrupt (^C etc) : Exit code 1, prints nothing to stdout
  On item confirmation  : Exit code 0, prints <index> <value> to stdout
                          Except when the selected value is '::quit::'

Special labels & values:
  Setting a label or a value to '::' copies its obverse property;
  Confirmation on a '::quit::' value is equivalent to pressing 'q'

Example:
  res=(\$($self 'Menu' -1 'Foo bar' :: 'Baz' 'Bizzle' Quit ::quit::)) || exit
  index="\${res[0]}"   # First parameter is the selected index
  value="\${res[@]:1}" # Remaining parameters are the value
  echo "User selected index \$index, value '\$value'"

EOF
}

ansi()            { echo -en "\033[$*" >&2; }
# CPL/CNL (CSI n F/E) are not well supported, so I use
# CUU/CUD (CSI n A/B) + CHA (CSI n G) instead:
goto_prev_row()   { ansi "$1A\033[G"; } # "$1F"
goto_next_row()   { ansi "$1B\033[G"; } # "$1E"
invert_color()    { ansi 7m; }
reset_color()     { ansi 0m; }
clear_to_end()    { ansi J; }

create_items() {
    menu_labels=() # global
    menu_values=() # global
    menu_length=1 # global
    while (( $# > 0 )); do
        a="$1" b="$2"
        [[ "$a" = '::' ]] && a="$b" || [[ "$b" = '::' ]] && b="$a"
        menu_labels+=("$a")
        menu_values+=("$b")
        (( menu_length++ ))
        shift 2
    done
    (( menu_end = menu_length - 1 ))
}

clear_item_area() {
    for (( i = 0; i < menu_length; i++ )); do
        clear_to_end
        echo >&2
    done
}

print_items() {
    local selected="$1"
    reset_color
    goto_prev_row $menu_end
    for (( i = 0; i < menu_length; i++ )); do
        if (( i == selected )); then
            invert_color
            echo -en "${menu_labels[$i]}" >&2
            reset_color
        else
            echo -en "${menu_labels[$i]}" >&2
        fi
        (( i < menu_length - 1 )) && goto_next_row
    done
}

select_item() {
    picked="$1"
    local last_picked=-1
    while true; do
        (( last_picked != picked)) && print_items $picked
        last_picked=$picked
        read -N 1 -r -s selection
        [[ "$selection" = $'\n' ]] && break
        # Up/down keys are escape codes on *NIX ([\r]\e[<code>); Scancode for
        # up/down on ISO keyboards will be ASCII A & B, the rest is chomped.
        # newline will also be slurped by '-r'.
        # Don't expect this to work everywhere.
        case "$selection" in
            q|Q) picked=-1; break ;;
            j|A) ((picked > 0 )) && ((picked--)) ;;
            k|B) ((picked < menu_end - 1 )) && ((picked++)) ;;
        esac
    done
}

(( $# < 4 )) && { show_usage; exit 0; }

trap "exit 1" INT

title="$1"
default="$2"
shift 2

create_items "$@" # sets `menu_{values,length,end}`

(( default >= menu_end )) && default=-1
(( default < 0 )) && (( default = menu_end + default ))
(( default < 0 )) && default=0

[[ -n "$title" ]] && echo "$title" >&2

clear_item_area
select_item "$default"
value="${menu_values[$picked]}"

if (( picked == -1 )) || [[ "$value" = "::quit::" ]]; then
    exit 2
fi

echo -n "$picked $value"
exit 0
