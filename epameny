#!/usr/bin/env bash
# epameny: A ridiculous ANSI menu written entirely in bash.
# By gammy, anno 2025. To reach me, try https://github.com/gammy
#
# This will not work on all setups: the keyboard input routine makes
# several assumtions regarding meta-keys in the operating environment.
# The display routines also assume that the terminal is at least
# somewhat aware of ANSI escape sequences.
#
# For a more robust & full-featured menu program, see dialog (1).
#
# Copyright (C) 2025 Kristian Gunstone
# Use of this source code is governed by the Simplified BSD License:
# https://opensource.org/license/bsd-2-clause

meny_version='0.9.9'
# echo "COLUMNS=$COLUMNS" >&2
# echo "LINES=$LINES" >&2
# exit

meny_simple=${meny_simple:-0}
default_height=${LINES:-25}
default_width=${COLUMNS:-80}
meny_height="${meny_height:-$default_height}"
meny_width="${meny_width:-$default_width}"
meny_limit="${meny_limit:-1000}"
meny_wrap="${meny_wrap:-0}"
meny_lslmark="${meny_lslmark:-\033[7m}" # SGR Invert
(( meny_width += (meny_awidth) ))
(( meny_height += (meny_aheight) ))

# meny_trim_spot -> meny_troffs
# meny_trim_mark -> meny_trmark

meny_trmark=${meny_trmark:- ~~ }
troffs_abs=${meny_troffs:-50%}
# meny_lsrmark= (no default)
# meny_lnlmark= (no default)
# meny_lnrmark= (no default)
if [[ "${troffs_abs: -1}" == '%' ]]; then
    (( troffs_abs = (${troffs_abs:0:-1} * meny_width) / 100 ))
fi
trmark_len=${#meny_trmark}
(( label_slen = troffs_abs - trmark_len ))
(( label_slen < 0)) && { (( troffs_abs += label_slen )); label_slen=0; }

# echo "trmark='$meny_trmark'" >&2
# echo "trmark_len=$trmark_len" >&2
# echo "label_slen=$label_slen" >&2
# exit

show_usage() {
    local self=$(basename "$0")
    cat <<EOF
$self v$meny_version: A ridiculous ANSI menu by gammy (code at gammy dot dev)

Usage:
  $self <default item index> <label> [<[value|label]>] [...]

Creates an interactive menu consisting of one or more label/value-pairs.
Once an item is confirmed, the associated item index & value is printed
to standard output for the caller to capture & process. The menu itself
is printed to standard error. In simple-mode (meny_simple=1), all items
are treated as labels with values set to '::' (see below).

Indexes count from 0: The first item is index 0, the fifth is index 4.
A negative default index can be used to select items in reverse order.

Keys:
  Up, l, A / Down, j, B  - Move the selection up / down.
  Return, Enter          - Confirm the item selection.
  q, Q                   - Exit immediately. See also '::quit::'.

Exit states:
  On immediate exit      - Exit code 2, prints nothing to stdout.
  On interrupt (^C etc)  - Exit code 1, prints nothing to stdout.
  On item confirmation   - Exit code 0, prints \$index \$value to stdout,
                           except when the selected value is '::quit::'.
Environment varibles:
  \$meny_simple           - Treat all items as labels with values set to '::'.
  \$meny_width            - Max. menu width. Ellipsises labels from the left.
  \$meny_height           - Max. number of items to display on the screen.
  \$meny_limit            - Max. number items to hold in the scroll-buffer.
  \$meny_wrap             - 0: Menu stops on its ends. 1: Menu wraps around.
  \$meny_lnlmark       - Text/ANSI before each non-selected item.
  \$meny_lnrmark       - Text/ANSI after each non-selected item.
  \$meny_lslmark       - Text/ANSI before the selected item.
  \$meny_lsrmark       - Text/ANSI after the selected item.
  \$meny_awidth      - Formula or value to add to \$meny_width.
  \$meny_aheight     - Formula or value to add to \$meny_height.
  \$meny_troffs           - Trim long labels at this column. If ending with '%'
                            the value represents a percentage of \$meny_width.
  \$meny_trmark           - Marker shown at \$meny_troffs on trimmed labels.
  Defaults:
    \$meny_simple         - 0        Treat arguments as label/value-pairs.
    \$meny_width          - \$COLUMNS if present, or 80 if not.
    \$meny_height         - \$LINES   if present, or 25 if not.
    \$meny_limit          - 1000     For unlimited items, set it to 0.
    \$meny_wrap           - 0        Menu stops at its ends.
    \$meny_lslmark     - "\\e[7m"  ANSI sequence for inverting color.

  As prefixes & suffixes might contain non-printable text (e.g ANSI), their
  string lengths cannot be used when calculating how much to trim the labels.
  As \$meny_width + \$meny_awidth = effective width, one solution is to set
  \$meny_awidth to the longest prefix / suffix width used. Given that
  \$meny_lnlmark='>' & \$meny_lsrmark='(select)', meny_awidth should
  be set to -8 (the width of the '(select)'-text) to prevent width-overflow.

Special labels & values (not applicable in simple-mode):
  A label or value set to '::' will copy the other field's content.
  A value set to '::quit::' behaves the same as if 'q' was pressed.

Examples:
  echo \$($self 0 'Hello' 'world!')

  res=(\$($self -1 'Item A' 123 'Item B' :: Quit ::quit::)) || exit
  index="\${res[0]}"   # Param 0 : item index
  value="\${res[@]:1}" # Param 1+: item value(s)
  echo "Item index \$index has value \${value@Q}"

EOF
}

write() { scrbuf+="$*"; }
ansi()  { scrbuf+="\033[$*"; }
#goto_next_row()    { ansi "$1B"; } # CUD: Cursor Dn (doesn't scroll)
goto_prev_row()     { ansi "$1A"; } # CUU: Cursor Up (doesn't scroll)
goto_col()          { ansi "$1G"; } # CHA: Cursor Horisontal Absolute
reset_color()       { ansi 0m; }    # SGR: Reset
clear_to_end()      { ansi J; }     # ED: Erase In Display
goto_next_row_alt() { write "\n"; } # Emulate CNL
goto_prev_row_alt() { goto_prev_row "$1"; goto_col 1; } # Emulate CPL

hide_cursor() { ansi "?25l"; }              # Hide Cursor (VT220)
show_cursor() { echo -en "\033[?25h" >&2; } # Show Cursor (VT220) (unbuffered)

update_screen() {
    echo -en "$scrbuf" >&2
    scrbuf=
}

update_viewport() {
    local dir=$1 buf_stop=$2 scr_stop=$3
    if (( pick == buf_stop )); then
        (( ! meny_wrap )) && return
        if (( dir == 1 )); then
            buf_offs=0 scr_offs=0 pick=0
            return
        fi
        (( buf_offs = menu_end - meny_zheight ))
        scr_offs=$meny_zheight
        pick=$meny_end
        return
    fi
    (( scr_offs == scr_stop )) && { (( buf_offs += dir )); return; }
    (( scr_offs += dir ))
}

read_key() {
    # Up & Down arrow keys will - if we're lucky - be translated to the key
    # sequences \e[A & \e[B by the terminal. As we ignore the first two
    # chars & slurp newline, Up & Down will be interpreted as A & B.
    # This is not a portable approach, but beggars can't be choosers.
    read -N 1 -r -s keypress
    case "$keypress" in
      $'\n') return 1;; # Confirm
        q|Q) pick=-1 ;; # Cancel
        k|A) update_viewport -1 0 0 ;; # Move up
        j|B) update_viewport 1 $menu_end $meny_zheight ;; # Move down
    esac
    return 0
}

load_items() {
    item_labels=() # global
    item_values=() # global
    num_items=0    # global
    local label value
    while (( $# > 0 )); do
        label="$1" value="$2"
        (( label_off = ${#label} - meny_width ))
        if (( label_off >= 0 )); then
            (( label_elen = (meny_width - trmark_len) + label_off ))
            (( label_off = (${#label} - label_slen) - trmark_len ))
            label_ltrim="${label:0:$label_slen}"
            label_rtrim="${label:$label_off:$label_elen}"
            label="${label_ltrim}${meny_trmark}${label_rtrim}"
        fi
        if (( ! meny_simple )); then
            if [[ "$label" = '::' ]]; then
                label="$value"
            elif [[ "$value" = '::' ]]; then
                value="$label"
            fi
            item_values+=("$value")
        fi
        item_labels+=("$label")
        (( num_items++ ))
        # XXX will break '::quit::' if clipped off. Solvable?
        (( meny_limit > 0 && num_items >= meny_limit )) && break
        shift $simple_offset
    done

}

render_items() {
    local suffix prefix std_width sel_width
    reset_color
    for (( i = 0; i < meny_height; i++ )); do
        (( item_index = buf_offs + i ))
        if (( item_index == pick )); then
            prefix="$meny_lslmark"
            suffix="$meny_lsrmark"
        else
            prefix="$meny_lnlmark"
            suffix="$meny_lnrmark"
        fi
        clear_to_end
        write "${prefix}${item_labels[$item_index]}${suffix}"
        reset_color
        (( i < meny_height - 1 )) && goto_next_row_alt
    done
}

select_item() {
    local last_pick=-1

    # Compute the initial viewport
    if (( pick > meny_zheight )); then
        (( buf_offs = pick - meny_zheight ))
        (( scr_offs = meny_zheight ))
    else
        (( buf_offs = 0 ))
        (( scr_offs = pick % meny_height ))
    fi

    # Start the event loop
    while true; do
        if (( last_pick != pick )); then
            render_items
            update_screen
            goto_prev_row_alt $meny_zheight
            last_pick=$pick
        fi
        read_key || return 0
        (( pick == -1 )) && return 1
        (( pick = buf_offs + scr_offs ))
    done
}

(( simple_offset = 2 - meny_simple ))

(( $# < (3 - meny_simple) )) \
    && { show_usage; exit 0; }
(( $# % simple_offset != (1 - meny_simple) )) \
    && { echo 'Unmatched label/value' >&2; exit 1; }

declare -n values_ptr
(( meny_simple )) && values_ptr=item_labels || values_ptr=item_values

trap 'exit 1' INT
trap 'show_cursor; echo >&2' EXIT

pick="${1:-0}"; shift

load_items "$@"

(( pick >= num_items ))       && pick=-1
(( pick < 0 ))                && (( pick = menu_end + pick ))
(( pick < 0 ))                && pick=0
(( meny_limit  <= 0 ))        && meny_limit=$num_items
(( meny_height <= 0 ))        && meny_height=$default_height
(( meny_height > num_items )) && meny_height=$num_items

(( meny_zheight = meny_height - 1 )) # (convenience)
(( menu_end = num_items - 1 ))       # (convenience)

# echo "meny_width=$meny_width" >&2
# echo "meny_height=$meny_height" >&2
# exit

scrbuf=
hide_cursor
select_item || exit 2

value="${values_ptr[$pick]}"
[[ "$value" == '::quit::' ]] && exit 2

echo -n "$pick $value"
exit 0
