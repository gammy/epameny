#!/usr/bin/env bash
# Epameny: A ridiculous ANSI menu written entirely in bash.
# Website: https://github.com/gammy/epameny
# By gammy, anno 2025.
#
# This script has limitations and may not work in your environment.
# See the README.md-file for more information, or peruse the code below.
#
# Copyright (C) 2025 Kristian Gunstone
# Use of this source code is governed by the Simplified BSD License:
# https://opensource.org/license/bsd-2-clause

meny_version='1.0.2'

if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -lt 43 ]; then
    echo "Bash version 4.3 or newer is required by epameny. Sorry." >&2
    exit 1
fi

default_pickfmt="\033[7m::label::\033[7m"
default_height=${LINES:-25}
default_width=${COLUMNS:-80}
default_reset=0m # SGR: Reset

meny_simple=${meny_simple:-0}
meny_limit=${meny_limit:-1000}
meny_width=${meny_width:-$default_width}
meny_height=${meny_height:-$default_height}
meny_wrap=${meny_wrap:-0}
meny_reset=${meny_reset:-$default_reset}
meny_pickfmt=${meny_pickfmt:-$default_pickfmt}
meny_trimmark=${meny_trimmark:-...}
trimcol=${meny_trimcol:-100%}

(( meny_width += (meny_awidth) ))
(( meny_height += (meny_aheight) ))
if [[ "${trimcol: -1}" == '%' ]]; then
    (( trimcol = (${trimcol:0:-1} * meny_width) / 100 ))
fi
trimcol_len=${#meny_trimmark}
(( marker_fit = meny_width >= trimcol_len ))
(( trim_align = meny_width * (trimcol > meny_width / 2) ))
(( head_align = meny_width - trimcol_len ))
head_len_lookup=("$trim_align" "$head_align")
if [[ -n "$meny_normfmt" ]]; then
    norm_beg=${meny_normfmt/::label::*/}
    norm_end=${meny_normfmt/*::label::/}
fi
if [[ -n "$meny_pickfmt" ]]; then
    pick_beg=${meny_pickfmt/::label::*/}
    pick_end=${meny_pickfmt/*::label::/}
fi

show_usage() {
    local self=$(basename "$0")
    cat <<EOF
$self v$meny_version: A ridiculous ANSI menu by gammy (code at gammy dot dev)

Usage:
  $self <label> <value> [<label> <value>] [...]
  meny_simple=1 $self <label> [label] [...]
  ... | $self -

Creates an interactive menu consisting of one or more label/value-pairs. \
Once an item is confirmed, the associated item index & value is printed \
to standard output for the caller to capture & process. The menu itself \
is printed to standard error. In simple-mode (meny_simple=1), all items \
are treated as labels with values set to '::' (see below). \
$self supports vertical scrolling, & width-trimming of labels.

Indexes count from 0: The first item is index 0, the fifth is index 4.

Keys:
  Up, l, A / Down, j, B  - Move the selection up / down.
  Return, Enter          - Confirm the item selection.
  q, Q                   - Exit immediately. See also '::quit::'.

Exit states:
  On immediate exit      - Exit code 2, prints nothing to stdout.
  On interrupt (^C etc)  - Exit code 1, prints nothing to stdout.
  On item confirmation   - Exit code 0, prints \$index \$value to stdout,
                           except when the selected value is '::quit::'.
Configurable varibles:
  \$meny_pick             - The default picked selection item index.
                           Negative values count backwards from the last item.
  \$meny_simple           - Treat all items as labels with values set to '::'.
  \$meny_width            - Max. menu width (see also trim options).
  \$meny_height           - Max. number of items to display on the screen.
  \$meny_limit            - Max. number items to hold in the scroll-buffer.
  \$meny_wrap             - 0: Menu stops on its ends. 1: Menu wraps around.
  \$meny_reset            - ANSI sequence printed at start & after each item.
  \$meny_pickfmt          - Label-format for the selected item.
  \$meny_normfmt          - Label-format for all other items.
  \$meny_awidth           - Formula or value to add to \$meny_width.
  \$meny_aheight          - Formula or value to add to \$meny_height.
  \$meny_trimmark         - Text shown at \$meny_trimcol on trimmed labels.
  \$meny_trimcol          - Trim long labels on this column position.
                           Represents % of terminal width when ending with '%'.
Default values:
  \$meny_pick             - 0    (the first item added is the default item)
  \$meny_simple           - 0    (disabled: items must contain a label & value)
  \$meny_wrap             - 0    (disabled: menu doesn't wrap around)
  \$meny_width            - auto (\$COLUMNS if \$COLUMNS is set, otherwise 80)
  \$meny_height           - auto (\$LINES   if \$LINES is set, otherwise 25)
  \$meny_limit            - 1000 (keep at most 1000 items in total)
  \$meny_trimcol          - 100% (labels too long get trimmed at the end)
  \$meny_trimmark         - ...  (on trimmed tails, show ... at \$meny_trimcol)
  \$meny_pickfmt          - ${default_pickfmt@Q} (invert colors)
  \$meny_reset            - ${default_reset@Q} (default colors)

The length of a label is computed without consideration of ANSI escape codes. \
Similarly, meny_pickfmt & meny_normfmt is also not considered. meny_awidth \
can be used to adjust the width-calculation if needed. For example if \
\$meny_normfmt='\\e[1m->::label::', meny_awidth should be set to -2 to \
account for the arrow whilst ignoring the invisible ANSI code for bolding it.

Placeholders:
  meny_pickfmt & meny_normfmt use '::label::' as a placeholder for labels.
  In normal mode (i.e meny_simple=0), the following applies to labels/values:
  A value set to '::' is substituted by its label & vice-versa.
  A value set to '::quit::' will upon selection act as if 'q' was pressed.

Examples:
  $self 'A label' 'A value'
  meny_simple=1 $self 'A label' 'Another label' 'And a third'
  data=(\$(meny_pick=-1 $self 'Item A' :: 'Item B' 123 Quit ::quit::)) || exit
  echo "Item index \${data[0]} has value \${data[@]:1}"
  ls | meny_simple=1 $self -

EOF
}

write() { scrbuf+="$*"; }
ansi()  { scrbuf+="\033[$*"; }
#goto_next_row()    { ansi "$1B"; } # CUD: Cursor Dn (doesn't scroll)
goto_prev_row()     { ansi "$1A"; } # CUU: Cursor Up (doesn't scroll)
goto_col()          { ansi "$1G"; } # CHA: Cursor Horisontal Absolute
reset_color()       { ansi "$meny_reset"; }
clear_to_end()      { ansi J; }     # ED: Erase In Display
goto_next_row_alt() { write "\n"; } # Emulate CNL
goto_prev_row_alt() { goto_prev_row "$1"; goto_col 1; } # Emulate CPL

hide_cursor() { ansi "?25l"; }              # Hide Cursor (VT220)
show_cursor() { echo -en "\033[?25h" >&2; } # Show Cursor (VT220) (unbuffered)

update_screen() {
    echo -en "$scrbuf" >&2
    scrbuf=
}

update_viewport() {
    local dir=$1 buf_stop=$2 scr_stop=$3
    if (( pick == buf_stop )); then
        (( ! meny_wrap )) && return
        if (( dir == 1 )); then
            buf_offs=0 scr_offs=0 pick=0
            return
        fi
        (( buf_offs = menu_end - meny_zheight ))
        scr_offs=$meny_zheight
        pick=$menu_end
        return
    fi
    (( scr_offs == scr_stop )) && { (( buf_offs += dir )); return; }
    (( scr_offs += dir ))
}

read_key() {
    # Up & Down arrow keys will - if we're lucky - be translated to the key
    # sequences \e[A & \e[B by the terminal. As we ignore the first two
    # chars & slurp newline, Up & Down will be interpreted as A & B.
    # This is not a portable approach, but beggars can't be choosers.
    read -N 1 -r -s keypress
    case "$keypress" in
      $'\n') return 1;; # Confirm
        q|Q) pick=-1 ;; # Cancel
        k|A) update_viewport -1 0 0 ;; # Move up
        j|B) update_viewport 1 $menu_end $meny_zheight ;; # Move down
    esac
    return 0
}

trim_label() {
    local -n text=$1 # Pointer to the actual label
    local text_len="${#text}"
    (( text_len <= meny_width )) && return
    # Note that `{head,mark,tail}_len` are modified on each label.
    local head_len="$trimcol" mark_len="$trimcol_len" tail_len \
          text_head tail_beg text_tail
    if (( (head_len + mark_len) >= meny_width )); then
        head_len=${head_len_lookup[$marker_fit]}
        (( mark_len *= marker_fit ))
    fi
    (( tail_len = meny_width - (head_len + mark_len) ))
    (( tail_beg = text_len - tail_len ))
    text_head="${text:0:$head_len}"
    text_tail="${text:$tail_beg:$tail_len}"
    text="${text_head}${meny_trimmark:0:$mark_len}${text_tail}"
}

load_items() {
    item_labels=() item_values=() num_items=0 # globals
    local label value
    while (( $# > 0 )); do
        label="$1" value="$2"
        if (( ! meny_simple )); then
            if [[ "$label" = '::' ]]; then
                label="$value"
            elif [[ "$value" = '::' ]]; then
                value="$label"
            fi
            item_values+=("$value")
        fi
        trim_label 'label'
        item_labels+=("$label")
        (( num_items++ ))
        # XXX will break '::quit::' if clipped off. Solvable?
        (( meny_limit > 0 && num_items >= meny_limit )) && break
        shift $args_per_item
    done
}

render_items() {
    local index i
    reset_color
    for (( i = 0; i < meny_height; i++ )); do
        clear_to_end
        (( index = buf_offs + i ))
        (( index == pick )) \
            && write "$pick_beg${item_labels[$index]}$pick_end" \
            || write "$norm_beg${item_labels[$index]}$norm_end"
        reset_color
        (( i < meny_height - 1 )) && goto_next_row_alt
    done
}

select_item() {
    local last_pick=-1
    # Compute the initial viewport
    if (( pick > meny_zheight )); then
        (( buf_offs = pick - meny_zheight ))
        (( scr_offs = meny_zheight ))
    else
        (( buf_offs = 0 ))
        (( scr_offs = pick % meny_height ))
    fi
    # The event loop
    while true; do
        if (( last_pick != pick )); then
            render_items
            update_screen
            goto_prev_row_alt $meny_zheight
            last_pick=$pick
        fi
        read_key || return 0
        (( pick == -1 )) && return 1
        (( pick = buf_offs + scr_offs ))
    done
}

(( $# < 1 )) && { show_usage; exit 0; }

(( $# == 1 )) && [[ "$1" == '-' ]] \
    && { mapfile -n "$meny_limit" -t list; exec 0>&1; } \
    || list=("$@")

(( ! meny_simple && ${#list[@]} % 2 != 0 )) \
    && { echo 'Unmatched label/value' >&2; exit 1; };

pick="${meny_pick:-0}"
(( args_per_item = 2 - meny_simple ))

trap 'exit 1' INT
trap 'show_cursor; echo >&2' EXIT

load_items "${list[@]}"
unset list

(( pick >= num_items ))       && pick=-1
(( pick < 0 ))                && (( pick = num_items + pick ))
(( pick < 0 ))                && pick=0
(( meny_limit  <= 0 ))        && meny_limit=$num_items
(( meny_height <= 0 ))        && meny_height=$default_height
(( meny_height > num_items )) && meny_height=$num_items
(( meny_zheight = meny_height - 1 )) # (convenience)
(( menu_end = num_items - 1 ))       # (convenience)

scrbuf=
hide_cursor; select_item || exit 2

if (( meny_simple )); then
    value="${item_labels[$pick]}"
else
    value="${item_values[$pick]}"
    [[ "$value" == '::quit::' ]] && exit 2
fi

echo -n "$pick $value"
exit 0
